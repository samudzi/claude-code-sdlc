#!/bin/bash
# Global pre-commit hook: linting + safety checks on staged files only
# Chains to legitimate local hooks; skips broken PLATFORM_REPO hooks

set -e

# --- Section 1: Chain to legitimate local hooks ---
if [[ -x ".git/hooks/pre-commit" ]]; then
    # Skip broken hooks that hardcode PLATFORM_REPO
    if grep -q 'PLATFORM_REPO="\$HOME/Workbench/platform"' ".git/hooks/pre-commit" 2>/dev/null; then
        : # Fall through to global checks
    else
        .git/hooks/pre-commit "$@"
        exit $?
    fi
fi

# --- Section 2: Bypass if project has local linting framework ---
if [[ -f ".pre-commit-config.yaml" ]] || \
   [[ -f ".pre-commit-config.yml" ]] || \
   [[ -d ".husky" ]] || \
   [[ -f ".huskyrc" ]] || \
   [[ -f ".huskyrc.json" ]] || \
   [[ -f "lefthook.yml" ]] || \
   [[ -f ".lefthook.yml" ]] || \
   [[ -f ".lintstagedrc" ]] || \
   [[ -f ".lintstagedrc.json" ]] || \
   [[ -f ".lintstagedrc.yml" ]] || \
   [[ -f ".lintstagedrc.js" ]] || \
   [[ -f ".lintstagedrc.mjs" ]]; then
    exit 0
fi
# Also check for lint-staged in package.json
if [[ -f "package.json" ]] && grep -q '"lint-staged"' "package.json" 2>/dev/null; then
    exit 0
fi

# --- Section 3: Get staged files ---
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [[ -z "$STAGED_FILES" ]]; then
    exit 0
fi

# --- Section 4: Standard linting ---
LINT_FAILED=0

# JavaScript/TypeScript
if echo "$STAGED_FILES" | grep -qE '\.(js|jsx|ts|tsx)$'; then
    JS_FILES=$(echo "$STAGED_FILES" | grep -E '\.(js|jsx|ts|tsx)$' || true)
    if [[ -n "$JS_FILES" ]]; then
        if [[ -f "node_modules/.bin/eslint" ]]; then
            echo "Running ESLint on staged JS/TS files..."
            echo "$JS_FILES" | xargs node_modules/.bin/eslint --fix || LINT_FAILED=1
            echo "$JS_FILES" | xargs git add
        elif command -v eslint &> /dev/null; then
            echo "Running global ESLint on staged JS/TS files..."
            echo "$JS_FILES" | xargs eslint || LINT_FAILED=1
        fi
    fi
fi

# Python
if echo "$STAGED_FILES" | grep -qE '\.py$'; then
    PY_FILES=$(echo "$STAGED_FILES" | grep -E '\.py$' || true)
    if [[ -n "$PY_FILES" ]]; then
        if command -v ruff &> /dev/null; then
            echo "Running Ruff on staged Python files..."
            echo "$PY_FILES" | xargs ruff check --fix || LINT_FAILED=1
            echo "$PY_FILES" | xargs git add
        elif command -v flake8 &> /dev/null; then
            echo "Running Flake8 on staged Python files..."
            echo "$PY_FILES" | xargs flake8 || LINT_FAILED=1
        fi
    fi
fi

# Go
if echo "$STAGED_FILES" | grep -qE '\.go$'; then
    if command -v gofmt &> /dev/null; then
        echo "Running gofmt on staged Go files..."
        GO_FILES=$(echo "$STAGED_FILES" | grep -E '\.go$' || true)
        echo "$GO_FILES" | xargs gofmt -w || LINT_FAILED=1
        echo "$GO_FILES" | xargs git add
    fi
fi

# Rust
if echo "$STAGED_FILES" | grep -qE '\.rs$'; then
    if command -v rustfmt &> /dev/null; then
        echo "Running rustfmt on staged Rust files..."
        RUST_FILES=$(echo "$STAGED_FILES" | grep -E '\.rs$' || true)
        echo "$RUST_FILES" | xargs rustfmt || LINT_FAILED=1
        echo "$RUST_FILES" | xargs git add
    fi
fi

# Shell scripts (linting via shellcheck)
if echo "$STAGED_FILES" | grep -qE '\.(sh|bash)$'; then
    SH_FILES=$(echo "$STAGED_FILES" | grep -E '\.(sh|bash)$' || true)
    if [[ -n "$SH_FILES" ]]; then
        if command -v shellcheck &> /dev/null; then
            echo "Running ShellCheck on staged shell scripts..."
            echo "$SH_FILES" | xargs shellcheck || LINT_FAILED=1
        fi
    fi
fi

# --- Section 5: Safety checks on staged files ---
SAFETY_FAILED=0

# Python safety checks
if echo "$STAGED_FILES" | grep -qE '\.py$'; then
    PY_FILES=$(echo "$STAGED_FILES" | grep -E '\.py$' || true)
    if [[ -n "$PY_FILES" ]]; then
        echo "Running Python safety checks on staged files..."
        while IFS= read -r pyfile; do
            [[ -z "$pyfile" ]] && continue
            # Check for hardcoded credentials
            if grep -nEi '(PASSWORD|SECRET|API_KEY)\s*=\s*["\x27][^"\x27]{8,}' "$pyfile" 2>/dev/null | grep -vE '(os\.environ|os\.getenv|config\[|settings\.)' > /dev/null; then
                echo "SAFETY: $pyfile - Potential hardcoded credential detected"
                SAFETY_FAILED=1
            fi
            # Check for dangerous calls
            if grep -nE '\b(eval|exec)\s*\(' "$pyfile" 2>/dev/null | grep -vE '^\s*#' > /dev/null; then
                echo "SAFETY: $pyfile - Dangerous eval()/exec() call detected"
                SAFETY_FAILED=1
            fi
            if grep -nE '\bpickle\.load\s*\(' "$pyfile" 2>/dev/null | grep -vE '^\s*#' > /dev/null; then
                echo "SAFETY: $pyfile - Dangerous pickle.load() call detected"
                SAFETY_FAILED=1
            fi
        done <<< "$PY_FILES"
    fi
fi

# Shell safety checks
if echo "$STAGED_FILES" | grep -qE '\.(sh|bash)$'; then
    SH_FILES=$(echo "$STAGED_FILES" | grep -E '\.(sh|bash)$' || true)
    if [[ -n "$SH_FILES" ]]; then
        SHELL_CHECKER="$HOME/.local/bin/safety-checkers/shell-safety-checker.sh"
        if [[ -f "$SHELL_CHECKER" ]]; then
            # Source checkShellFile() in a subshell to isolate set -euo pipefail
            echo "Running shell safety checks (via shell-safety-checker.sh)..."
            while IFS= read -r shfile; do
                [[ -z "$shfile" ]] && continue
                (
                    source "$SHELL_CHECKER"
                    checkShellFile "$shfile"
                ) || SAFETY_FAILED=1
            done <<< "$SH_FILES"
        else
            # Fallback: inline safety checks
            echo "Running shell safety checks (inline fallback)..."
            while IFS= read -r shfile; do
                [[ -z "$shfile" ]] && continue
                # Check shebang
                if ! head -1 "$shfile" | grep -q '^#!/.*bash'; then
                    echo "SAFETY: $shfile - Missing or incorrect shebang"
                    SAFETY_FAILED=1
                fi
                # Check set -euo pipefail
                if ! head -20 "$shfile" | grep -q 'set -euo pipefail'; then
                    echo "SAFETY: $shfile - Missing 'set -euo pipefail'"
                    SAFETY_FAILED=1
                fi
                # Check hardcoded credentials
                if grep -nEi '(PASSWORD|SECRET|API_KEY)\s*=\s*[a-zA-Z0-9_]{10,}' "$shfile" 2>/dev/null | grep -vE '(\$\{|\$\(|getenv)' > /dev/null; then
                    echo "SAFETY: $shfile - Potential hardcoded credential detected"
                    SAFETY_FAILED=1
                fi
            done <<< "$SH_FILES"
        fi
    fi
fi

# --- Section 6: Exit with combined status ---
if [[ $LINT_FAILED -ne 0 ]] || [[ $SAFETY_FAILED -ne 0 ]]; then
    [[ $LINT_FAILED -ne 0 ]] && echo "Linting failed. Please fix the issues and try again."
    [[ $SAFETY_FAILED -ne 0 ]] && echo "Safety checks failed. Please fix the issues and try again."
    exit 1
fi

exit 0
